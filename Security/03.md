# How does Istio service mesh deal with security?
Istio æœåŠ¡ç½‘æ ¼å¦‚ä½•å¤„ç†å®‰å…¨æ€§ï¼Ÿ

* https://tetratelabs.io/blog/istio-security/

In this blog, I will explain how Istio can help to solve issues such as encrypting traffic, provide flexible service access control, configure mutual TLS and fine-grained access policies and auditing.
åœ¨è¿™ç¯‡åšå®¢ä¸­ï¼Œæˆ‘å°†è§£é‡Š Istio å¦‚ä½•å¸®åŠ©è§£å†³åŠ å¯†æµé‡ã€æä¾›çµæ´»çš„æœåŠ¡è®¿é—®æ§åˆ¶ã€é…ç½®åŒå‘ TLS ä»¥åŠç»†ç²’åº¦çš„è®¿é—®ç­–ç•¥å’Œå®¡æ ¸ç­‰é—®é¢˜ã€‚

## Istio Security Architecture
Istio å®‰å…¨æ¶æ„

The following Istio components are involved in providing security features in Istio:
ä»¥ä¸‹ Istio ç»„ä»¶å‚ä¸åœ¨ Istio ä¸­æä¾›å®‰å…¨åŠŸèƒ½ï¼š

- Certificate authority (CA) for managing keys and certificates
  ç”¨äºç®¡ç†å¯†é’¥å’Œè¯ä¹¦çš„è¯ä¹¦é¢å‘æœºæ„ (CA)

- Sidecar and perimeter proxies: implement secure communication between clients and servers (they work as Policy Enforcement Points (PEPs))
  Sidecar å’Œå¤–å›´ä»£ç†ï¼šå®ç°å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´çš„å®‰å…¨é€šä¿¡ï¼ˆå®ƒä»¬ä½œä¸ºç­–ç•¥æ‰§è¡Œç‚¹ (PEP)ï¼‰

- Envoy proxy extensions: manage telemetry and auditing
  Envoy ä»£ç†æ‰©å±•ï¼šç®¡ç†é¥æµ‹å’Œå®¡è®¡

- Configuration API server: distributes authentication, authorization policies and secure naming information
  é…ç½®APIæœåŠ¡å™¨ï¼šåˆ†å‘è®¤è¯ã€æˆæƒç­–ç•¥å’Œå®‰å…¨å‘½åä¿¡æ¯

> Policy Enforcement Point (PEP) is a component that serves as a gatekeeper to a resource.
> ç­–ç•¥æ‰§è¡Œç‚¹ (PEP) æ˜¯å……å½“èµ„æºçœ‹é—¨äººçš„ç»„ä»¶ã€‚

Letâ€™s look at the architecture diagram in the figure below for different components and their responsibilities.
æˆ‘ä»¬çœ‹ä¸€ä¸‹ä¸‹å›¾ä¸­çš„æ¶æ„å›¾ï¼Œäº†è§£ä¸åŒçš„ç»„ä»¶åŠå…¶èŒè´£ã€‚

![Istio Security Architecture](https://tetratelabs.io/blog/istio-security/security-arch-diagram.png)

## Authentication
è®¤è¯

Based on the definition, authentication is a process or action of verifying the identity of a user or a process. This means Istio needs to extract credentials from requests and prove they are authentic. Envoy proxies in Istio are using a certificate for their credentials when communicating with each other. These certificates are tied to service accounts in Kubernetes.
æ ¹æ®å®šä¹‰ï¼Œèº«ä»½éªŒè¯æ˜¯éªŒè¯ç”¨æˆ·æˆ–è¿›ç¨‹èº«ä»½çš„è¿‡ç¨‹æˆ–æ“ä½œã€‚è¿™æ„å‘³ç€ Istio éœ€è¦ä»è¯·æ±‚ä¸­æå–å‡­æ®å¹¶è¯æ˜å®ƒä»¬æ˜¯çœŸå®çš„ã€‚Istio ä¸­çš„ Envoy ä»£ç†åœ¨ç›¸äº’é€šä¿¡æ—¶ä½¿ç”¨è¯ä¹¦ä½œä¸ºå…¶å‡­æ®ã€‚è¿™äº›è¯ä¹¦ä¸ Kubernetes ä¸­çš„æœåŠ¡å¸æˆ·ç»‘å®šã€‚

When two services start communicating, they need to exchange the credentials with identity information to mutually authenticate themselves. The client checks the serverâ€™s identity against theÂ **secure naming**Â information to see if it is an authorized runner of the service. On the server-side, the server determines what information the client can access based on theÂ **authorization policies**. Additionally, the server can audit who accessed what at what time, and make decisions whether to approve or reject clients from making calls to the server. The secure naming information contains mappings from service identities to the service names. The server identities are encoded in certificates, and the service names are names used by the discovery service or DNS. A single mapping from an identity A to a service name B means that â€œA is allowed and authorized service Bâ€. Secure naming information gets generated by the Pilot and then distributed to all sidecar Envoys.
å½“ä¸¤ä¸ªæœåŠ¡å¼€å§‹é€šä¿¡æ—¶ï¼Œå®ƒä»¬éœ€è¦äº¤æ¢å¸¦æœ‰èº«ä»½ä¿¡æ¯çš„å‡­è¯ä»¥ç›¸äº’éªŒè¯è‡ªå·±çš„èº«ä»½ã€‚ å®¢æˆ·ç«¯æ ¹æ®å®‰å…¨å‘½åä¿¡æ¯æ£€æŸ¥æœåŠ¡å™¨çš„èº«ä»½ï¼Œä»¥æŸ¥çœ‹å®ƒæ˜¯å¦æ˜¯è¯¥æœåŠ¡çš„æˆæƒè¿è¡Œè€…ã€‚ åœ¨æœåŠ¡å™¨ç«¯ï¼ŒæœåŠ¡å™¨æ ¹æ®æˆæƒç­–ç•¥å†³å®šå®¢æˆ·ç«¯å¯ä»¥è®¿é—®å“ªäº›ä¿¡æ¯ã€‚ æ­¤å¤–ï¼ŒæœåŠ¡å™¨è¿˜å¯ä»¥å®¡æ ¸è°åœ¨ä½•æ—¶è®¿é—®äº†ä»€ä¹ˆå†…å®¹ï¼Œå¹¶å†³å®šæ˜¯å¦æ‰¹å‡†æˆ–æ‹’ç»å®¢æˆ·ç«¯å‘æœåŠ¡å™¨å‘å‡ºè°ƒç”¨ã€‚ å®‰å…¨å‘½åä¿¡æ¯åŒ…å«ä»æœåŠ¡æ ‡è¯†åˆ°æœåŠ¡åç§°çš„æ˜ å°„ã€‚ æœåŠ¡å™¨èº«ä»½ç¼–ç åœ¨è¯ä¹¦ä¸­ï¼ŒæœåŠ¡åç§°æ˜¯å‘ç°æœåŠ¡æˆ– DNS ä½¿ç”¨çš„åç§°ã€‚ ä»èº«ä»½ A åˆ°æœåŠ¡åç§° B çš„å•ä¸ªæ˜ å°„æ„å‘³ç€â€œA è¢«å…è®¸å¹¶æˆæƒæœåŠ¡ Bâ€ã€‚ å®‰å…¨å‘½åä¿¡æ¯ç”± Pilot ç”Ÿæˆï¼Œç„¶ååˆ†å‘ç»™æ‰€æœ‰ sidecar Envoyã€‚

## Identity
èº«ä»½

For issuing identities, Istio uses Secure Production Identity Framework for Everyone, or SPIFFE (pronouncedÂ *spiffy*). SPIFFE is a specification for a framework that can bootstrap and issue identities. Citadel implements the SPIFFE spec; another implementation of SPIFFE is called SPIRE (SPIFFE Runtime Framework).
ä¸ºäº†å‘å¸ƒèº«ä»½ï¼ŒIstio ä½¿ç”¨é€‚ç”¨äºæ¯ä¸ªäººçš„å®‰å…¨ç”Ÿäº§èº«ä»½æ¡†æ¶ï¼Œæˆ– SPIFFEï¼ˆå‘éŸ³ä¸º spiffyï¼‰ã€‚ SPIFFE æ˜¯ä¸€ä¸ªå¯ä»¥å¼•å¯¼å’Œé¢å‘èº«ä»½çš„æ¡†æ¶è§„èŒƒã€‚ Citadel å®æ–½ SPIFFE è§„èŒƒï¼› SPIFFE çš„å¦ä¸€ä¸ªå®ç°ç§°ä¸º SPIREï¼ˆSPIFFE è¿è¡Œæ—¶æ¡†æ¶ï¼‰ã€‚

There are three concepts to the SPIFFE standard:
SPIFFE æ ‡å‡†åŒ…å«ä¸‰ä¸ªæ¦‚å¿µï¼š

- SPIFFE ID: identity namespace that defines how service identify themselves
  SPIFFE IDï¼šå®šä¹‰æœåŠ¡å¦‚ä½•è¯†åˆ«è‡ªèº«çš„èº«ä»½å‘½åç©ºé—´

- SPIFFE Verifiable Identity Document (SVID): dictates how an issued identity is presented and verified. It encodes the SPIFFE ID.
  SPIFFE å¯éªŒè¯èº«ä»½æ–‡æ¡£ (SVID)ï¼šè§„å®šå¦‚ä½•å‘ˆç°å’ŒéªŒè¯é¢å‘çš„èº«ä»½ã€‚ å®ƒå¯¹ SPIFFE ID è¿›è¡Œç¼–ç ã€‚

- Workload API: specifies an API for a workload issuing and/or retrieving antoher workloadâ€™s SVID
  å·¥ä½œè´Ÿè½½ APIï¼šæŒ‡å®šç”¨äºå‘å‡ºå’Œ/æˆ–æ£€ç´¢å¦ä¸€ä¸ªå·¥ä½œè´Ÿè½½çš„ SVID çš„å·¥ä½œè´Ÿè½½çš„ API

In Kubernetes, service accounts are used for service identity. The URI that represents the SPIFFE ID is formatted like this:Â `spiffe://cluster-name/ns/namespace/sa/service-account-name`. By default, any pods that donâ€™t set a service account explicitly will use the default service account thatâ€™s deployed in a namespace.
åœ¨ Kubernetes ä¸­ï¼ŒæœåŠ¡å¸æˆ·ç”¨äºæœåŠ¡èº«ä»½ã€‚ è¡¨ç¤º SPIFFE ID çš„ URI æ ¼å¼å¦‚ä¸‹ï¼šspiffe://cluster-name/ns/namespace/sa/service-account-nameã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œä»»ä½•æœªæ˜¾å¼è®¾ç½®æœåŠ¡å¸æˆ·çš„ pod å°†ä½¿ç”¨éƒ¨ç½²åœ¨å‘½åç©ºé—´ä¸­çš„é»˜è®¤æœåŠ¡å¸æˆ·ã€‚

You can take look at the service account and the corresponding secret like this:
æ‚¨å¯ä»¥åƒè¿™æ ·æŸ¥çœ‹æœåŠ¡å¸æˆ·å’Œç›¸åº”çš„ç§˜å¯†ï¼š

```sh
$ kubectl describe sa default
Name:                default
Namespace:           default
Labels:              <none>
Annotations:         <none>
Image pull secrets:  <none>
Mountable secrets:   default-token-pjqr9
Tokens:              default-token-pjqr9
Events:              <none>
```

The mountable secret/token name is the name of the secret in the same namespace that contains the certificate and token.

```sh
$ kubectl describe secret default-token-pjqr9

Name:         default-token-pjqr9
Namespace:    default
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: default
              kubernetes.io/service-account.uid: fe107ed9-8707-11e9-9803-025000000001

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1025 bytes
namespace:  7 bytes
token:      ey....
```

The SPIFFE ID for the default service account would therefore be encoded like this:Â *spiffe://cluster.local/ns/default/sa/default*. The specification also describes how to encode this identity into a certificate that can be used to prove the identity. The SPIFFE says that the identity (the URI) needs to be encoded in the certificateâ€™s subject alternative name (SAN).
å› æ­¤ï¼Œé»˜è®¤æœåŠ¡å¸æˆ·çš„ SPIFFE ID å°†æŒ‰å¦‚ä¸‹æ–¹å¼ç¼–ç ï¼šspiffe://cluster.local/ns/default/sa/defaultã€‚ è¯¥è§„èŒƒè¿˜æè¿°äº†å¦‚ä½•å°†æ­¤èº«ä»½ç¼–ç åˆ°å¯ç”¨äºè¯æ˜èº«ä»½çš„è¯ä¹¦ä¸­ã€‚ SPIFFE è¡¨ç¤ºèº«ä»½ï¼ˆURIï¼‰éœ€è¦ç¼–ç åœ¨è¯ä¹¦çš„ä½¿ç”¨è€…å¤‡ç”¨åç§°ï¼ˆSANï¼‰ä¸­ã€‚

Finally, the workload API for issuing and retrieving SVIDs in Istio is implemented using ACME (Automatic Certificate Management Environment) protocol.
æœ€åï¼ŒIstio ä¸­ç”¨äºå‘å¸ƒå’Œæ£€ç´¢ SVID çš„å·¥ä½œè´Ÿè½½ API æ˜¯ä½¿ç”¨ ACMEï¼ˆè‡ªåŠ¨è¯ä¹¦ç®¡ç†ç¯å¢ƒï¼‰åè®®å®ç°çš„ã€‚

The Citadel component automatically creates the certificate for existing and new service accounts, then stores them as Kubernetes secrets. If you create a deployment and look at the pod spec, you will notice something like this:
Citadel ç»„ä»¶è‡ªåŠ¨ä¸ºç°æœ‰å’Œæ–°æœåŠ¡å¸æˆ·åˆ›å»ºè¯ä¹¦ï¼Œç„¶åå°†å®ƒä»¬å­˜å‚¨ä¸º Kubernetes æœºå¯†ã€‚ å¦‚æœæ‚¨åˆ›å»ºéƒ¨ç½²å¹¶æŸ¥çœ‹ Pod è§„èŒƒï¼Œæ‚¨ä¼šæ³¨æ„åˆ°ç±»ä¼¼ä»¥ä¸‹å†…å®¹ï¼š

```sh
...
 volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: default-token-pjqr9
      readOnly: true
...
```

Using this snippet, Kubernetes mounts the certificate and other information from the service account to the pod. Because issued certificates are short-lived for security purposes (i.e. even if the attacker can get the SVID, they can only use it for a short time), Citadel ensures that certificates get rotated automatically.
ä½¿ç”¨æ­¤ä»£ç ç‰‡æ®µï¼ŒKubernetes å°†è¯ä¹¦å’Œå…¶ä»–ä¿¡æ¯ä»æœåŠ¡å¸æˆ·æŒ‚è½½åˆ° podã€‚ ç”±äºå‡ºäºå®‰å…¨ç›®çš„ï¼Œé¢å‘çš„è¯ä¹¦æ˜¯çŸ­æš‚çš„ï¼ˆå³å³ä½¿æ”»å‡»è€…å¯ä»¥è·å¾— SVIDï¼Œä»–ä»¬ä¹Ÿåªèƒ½åœ¨çŸ­æ—¶é—´å†…ä½¿ç”¨å®ƒï¼‰ï¼ŒCitadel ç¡®ä¿è¯ä¹¦è‡ªåŠ¨è½®æ¢ã€‚

### Mutual TLS authentication
åŒå‘ TLS èº«ä»½éªŒè¯

Transport authentication, also known as service-to-service authentication is one of the authentication types supported by Istio. Istio implements mutual TLS as a solution for transport authentication.
ä¼ è¾“èº«ä»½éªŒè¯ï¼Œä¹Ÿç§°ä¸ºæœåŠ¡åˆ°æœåŠ¡èº«ä»½éªŒè¯ï¼Œæ˜¯ Istio æ”¯æŒçš„èº«ä»½éªŒè¯ç±»å‹ä¹‹ä¸€ã€‚ Istio å®ç°åŒå‘ TLS ä½œä¸ºä¼ è¾“èº«ä»½éªŒè¯çš„è§£å†³æ–¹æ¡ˆã€‚

TLS stands for Transport Layer Security. TLS is used each time you try to access a secure endpoint. For example, visitingÂ [https://learnistio.com](https://learnistio.com/)Â over HTTPS leverages TLS to secure the communication between the server where the website is running, and your browser. It doesnâ€™t even matter if sensitive or private information is being transferred - the connection is secured regardless.
TLS ä»£è¡¨ä¼ è¾“å±‚å®‰å…¨ã€‚ æ¯æ¬¡å°è¯•è®¿é—®å®‰å…¨ç«¯ç‚¹æ—¶éƒ½ä¼šä½¿ç”¨ TLSã€‚ ä¾‹å¦‚ï¼Œé€šè¿‡ HTTPS è®¿é—® https://learnistio.com ä¼šåˆ©ç”¨ TLS æ¥ä¿æŠ¤è¿è¡Œç½‘ç«™çš„æœåŠ¡å™¨ä¸æµè§ˆå™¨ä¹‹é—´çš„é€šä¿¡ã€‚ æ˜¯å¦ä¼ è¾“æ•æ„Ÿæˆ–ç§äººä¿¡æ¯å¹¶ä¸é‡è¦â€”â€”æ— è®ºå¦‚ä½•ï¼Œè¿æ¥éƒ½æ˜¯å®‰å…¨çš„ã€‚

Using TLS requires a certificate authority (CA) to issue a digital certificate to the server, and this server then hands it over to the browser for validation with the CA.
ä½¿ç”¨ TLS éœ€è¦è¯ä¹¦é¢å‘æœºæ„ (CA) å‘æœåŠ¡å™¨é¢å‘æ•°å­—è¯ä¹¦ï¼Œç„¶åæœåŠ¡å™¨å°†å…¶äº¤ç»™æµè§ˆå™¨ä»¥é€šè¿‡ CA è¿›è¡ŒéªŒè¯ã€‚

mTLS takes the same idea but applies it to applications or services. This means that instead of the client only verifying the servers' certificate, the server also verifies the clients certificate.
mTLS é‡‡ç”¨ç›¸åŒçš„æƒ³æ³•ï¼Œä½†å°†å…¶åº”ç”¨äºåº”ç”¨ç¨‹åºæˆ–æœåŠ¡ã€‚ è¿™æ„å‘³ç€æœåŠ¡å™¨ä¸ä»…ä¼šéªŒè¯æœåŠ¡å™¨çš„è¯ä¹¦ï¼Œè¿˜ä¼šéªŒè¯å®¢æˆ·ç«¯çš„è¯ä¹¦ï¼Œè€Œä¸æ˜¯å®¢æˆ·ç«¯ã€‚

An example of TLS would be crossing a border where you need to present your passport (a certificate) to the customs officer. Customs officer ensures your passport is valid, hasnâ€™t expired, etc. In the mTLS case, you would also ask for a passport from the customs officer, and you would validate it.
TLS çš„ä¸€ä¸ªä¾‹å­æ˜¯è·¨è¶Šè¾¹å¢ƒï¼Œæ‚¨éœ€è¦å‘æµ·å…³å®˜å‘˜å‡ºç¤ºæ‚¨çš„æŠ¤ç…§ï¼ˆè¯ä¹¦ï¼‰ã€‚ æµ·å…³å®˜å‘˜ä¼šç¡®ä¿æ‚¨çš„æŠ¤ç…§æœ‰æ•ˆã€æœªè¿‡æœŸç­‰ã€‚åœ¨ mTLS æƒ…å†µä¸‹ï¼Œæ‚¨è¿˜éœ€è¦å‘æµ·å…³å®˜å‘˜ç´¢è¦æŠ¤ç…§ï¼Œå¹¶å¯¹å…¶è¿›è¡ŒéªŒè¯ã€‚

Once both parties have validated the certificates with their respective CAs, the communication between parties can happen securely.
ä¸€æ—¦åŒæ–¹éƒ½é€šè¿‡å„è‡ªçš„ CA éªŒè¯äº†è¯ä¹¦ï¼ŒåŒæ–¹ä¹‹é—´çš„é€šä¿¡å°±å¯ä»¥å®‰å…¨åœ°è¿›è¡Œã€‚

In the case of Istio, all communication between services goes through the Envoy proxies. Here are the steps that happen when the call gets made from service A to service B:
å°± Istio è€Œè¨€ï¼ŒæœåŠ¡ä¹‹é—´çš„æ‰€æœ‰é€šä¿¡éƒ½é€šè¿‡ Envoy ä»£ç†è¿›è¡Œã€‚ ä»¥ä¸‹æ˜¯ä»æœåŠ¡ A è°ƒç”¨æœåŠ¡ B æ—¶å‘ç”Ÿçš„æ­¥éª¤ï¼š

1. Traffic gets routed from service A to the Envoy proxy in the same pod
   æµé‡ä»æœåŠ¡ A è·¯ç”±åˆ°åŒä¸€ Pod ä¸­çš„ Envoy ä»£ç†

2. Service A proxy starts an mTLS handshake with the Service B proxy (secure naming check happens as well)
   æœåŠ¡ A ä»£ç†å¯åŠ¨ä¸æœåŠ¡ B ä»£ç†çš„ mTLS æ¡æ‰‹ï¼ˆä¹Ÿä¼šè¿›è¡Œå®‰å…¨å‘½åæ£€æŸ¥ï¼‰

3. mTLS connection gets established
   mTLS è¿æ¥å»ºç«‹

4. Traffic gets forwarded to the Service B proxy
   æµé‡è½¬å‘åˆ°æœåŠ¡ B ä»£ç†

5. Service B proxy forwards traffic to the service B in the same pod
   æœåŠ¡Bä»£ç†å°†æµé‡è½¬å‘åˆ°åŒä¸€podä¸­çš„æœåŠ¡B

Mutual TLS in Istio supports a permissive mode. This mode allows a service to accept both plain text traffic and mTLS traffic at the same time. This can help you gradually migrate your services to mTLS, without breaking existing plain text traffic. Once all services have the proxy, you can configure mTLS only mode instead.
Istio ä¸­çš„ç›¸äº’ TLS æ”¯æŒå®½å®¹æ¨¡å¼ã€‚ æ­¤æ¨¡å¼å…è®¸æœåŠ¡åŒæ—¶æ¥å—çº¯æ–‡æœ¬æµé‡å’Œ mTLS æµé‡ã€‚ è¿™å¯ä»¥å¸®åŠ©æ‚¨é€æ­¥å°†æœåŠ¡è¿ç§»åˆ° mTLSï¼Œè€Œä¸ä¼šç ´åç°æœ‰çš„çº¯æ–‡æœ¬æµé‡ã€‚ ä¸€æ—¦æ‰€æœ‰æœåŠ¡éƒ½æœ‰ä»£ç†ï¼Œæ‚¨å°±å¯ä»¥é…ç½®ä»… mTLS æ¨¡å¼ã€‚

To configure mTLS between services, the traffic policy field in the destination rule is used. For example, to require a client to use mTLS when communcating with the service-b, youâ€™d use theÂ `ISTIO_MUTUAL`Â mode:
è¦åœ¨æœåŠ¡ä¹‹é—´é…ç½® mTLSï¼Œéœ€è¦ä½¿ç”¨ç›®æ ‡è§„åˆ™ä¸­çš„æµé‡ç­–ç•¥å­—æ®µã€‚ ä¾‹å¦‚ï¼Œè¦è¦æ±‚å®¢æˆ·ç«¯åœ¨ä¸ service-b é€šä¿¡æ—¶ä½¿ç”¨ mTLSï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ ISTIO_MUTUAL æ¨¡å¼ï¼š

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: service-b-istio-mtls
spec:
  host: service-b.default.svc.cluster.local
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
```

You could also provide your own certificates and set mode toÂ `MUTUAL`Â like this:

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: service-b-mtls
spec:
  host: service-b.default.svc.cluster.local
  trafficPolicy:
    tls:
      mode: MUTUAL
      clientCertificate: /etc/certs/cert.pem
      privateKey: /etc/certs/pkey.pem
      caCertificates: /etc/certs/cacerts.pem
```

Finally, you can set the mode field toÂ `SIMPLE`Â to configure the client to use TLS:

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: service-b-tls
spec:
  host: service-b.default.svc.cluster.local
  trafficPolicy:
    tls:
      mode: SIMPLE
```

### Origin authentication

Origin authentication, known as end-user authentication, is used for verifying original clients requesting as an end-user or device. Istio enables original authentication with JSON Web Token (JWT) validation and open-source OpenID connect providers (e.g. Googe Auth, Auth0 or Firebase Auth).
åŸå§‹èº«ä»½éªŒè¯ï¼Œç§°ä¸ºæœ€ç»ˆç”¨æˆ·èº«ä»½éªŒè¯ï¼Œç”¨äºéªŒè¯ä½œä¸ºæœ€ç»ˆç”¨æˆ·æˆ–è®¾å¤‡å‘å‡ºè¯·æ±‚çš„åŸå§‹å®¢æˆ·ç«¯ã€‚ Istio é€šè¿‡ JSON Web ä»¤ç‰Œ (JWT) éªŒè¯å’Œå¼€æº OpenID è¿æ¥æä¾›ç¨‹åºï¼ˆä¾‹å¦‚ Googe Authã€Auth0 æˆ– Firebase Authï¼‰å¯ç”¨åŸå§‹èº«ä»½éªŒè¯ã€‚

In the case of origin authentication (JWT), the application itself is responsible for acquiring and attaching the JWT token to the request.
åœ¨æºèº«ä»½éªŒè¯ (JWT) çš„æƒ…å†µä¸‹ï¼Œåº”ç”¨ç¨‹åºæœ¬èº«è´Ÿè´£è·å– JWT ä»¤ç‰Œå¹¶å°†å…¶é™„åŠ åˆ°è¯·æ±‚ã€‚

### Authentication policies

Authentication policies are used to specify authentication requirements for services within the mesh. Similarly, as with traffic routing, Pilot watches for changes in the policy resources and then translates and pushes the configuration to the Envoy proxies.
èº«ä»½éªŒè¯ç­–ç•¥ç”¨äºæŒ‡å®šç½‘æ ¼å†…æœåŠ¡çš„èº«ä»½éªŒè¯è¦æ±‚ã€‚ ç±»ä¼¼åœ°ï¼Œä¸æµé‡è·¯ç”±ä¸€æ ·ï¼ŒPilot ä¼šç›‘è§†ç­–ç•¥èµ„æºçš„å˜åŒ–ï¼Œç„¶åå°†é…ç½®è½¬æ¢å¹¶æ¨é€åˆ° Envoy ä»£ç†ã€‚

These policies define what authentication methods can be accepted (i.e. requests being received). While for the outgoing requests, you would use the destination rule as explained earlier in this blog. The figure below illustrates this:
è¿™äº›ç­–ç•¥å®šä¹‰å¯ä»¥æ¥å—å“ªäº›èº«ä»½éªŒè¯æ–¹æ³•ï¼ˆå³æ¥æ”¶è¯·æ±‚ï¼‰ã€‚ å¯¹äºä¼ å‡ºè¯·æ±‚ï¼Œæ‚¨å°†ä½¿ç”¨æœ¬åšå®¢å‰é¢æ‰€è¿°çš„ç›®æ ‡è§„åˆ™ã€‚ ä¸‹å›¾è¯´æ˜äº†è¿™ä¸€ç‚¹ï¼š

![Destination rule vs. Policy](https://tetratelabs.io/blog/istio-security/dest-vs-policy.png)

Authentication policies can be defined in two scopes that are explained next.

**Namespace-scoped policy**

The policies in the namespace scope can only affect services running in the same namespace. Additionally, you need to specify the namespace name, otherwise, the default namespace is used. Hereâ€™s an example of a namespace policy for theÂ `prod`Â namespace:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
spec:
  mtls:
    mode: STRICT
```

**Mesh-scoped policy**

Mesh-scoped policies can apply to all services in the mesh. You can only define one mesh-scope policy with the nameÂ `default`Â and an empty targets section. One difference from the namespace-scoped policy is the resource name. While namespace-scope policy resource is called â€œPolicyâ€ the mesh-scoped policy resource is called â€œMeshPolicyâ€.

#### Target selectors

To define which services are affected by the policies, target selectors are used. Target selectors are a list of rules to selected services that the policy should be applied. If a target selector is not provided, the policy is used on all services in the same namespace.

For example, a namespace-scope policy below would apply for theÂ `service-a`Â (regardless of the ports) andÂ `service-b`Â on portÂ `8080`:

```yaml
apiVersion: authentication.istio.io/v1alpha1
kind: PeerAuthentication
metadata:
  name: sample-policy
  namespace: prod
spec:
  target:
  - name: service-a
  - name: service-b
    ports:
    - number: 8080
```

In the case of multiple policies, they get evaluated from the narrowest matching policy (e.g. service-specific), to namespace and the mesh wide. If more than one policies apply to a service, one is randomly chosen.

#### Transport authentication

The field calledÂ `peers`Â defines the authentication methods and any parameters for the method. At the time of writing this, the only supported authentication method is mTLS. To enable it, use theÂ `mtls`Â key like this (using the previous example):

```yaml
apiVersion: authentication.istio.io/v1alpha1
kind: PeerAuthentication
metadata:
  name: sample-policy
  namespace: prod
spec:
  target:
  - name: service-a
  - name: service-b
    ports:
    - number: 8080
  peers:
    - mtls:
...
```

#### Origin authentication

The only origin authentication currently supported by Istio is JWT. Using theÂ `origins`Â field, you can define the method and parameters, such as allowed JWT issuers and enable or disable JWT authentication for a specific path. Hereâ€™s a sample snippet that shows how to define origin authentication that accepts JWTs issued by Google. Additionally, we are excluding theÂ `/health`Â path from JWT authentication:

```yaml
origins:
- jwt:
    issuer: https://accounts.google.com
    jwksUri: https://www.googleapis.com/oauth2/v3/certs
    trigger_rules:
    - excluded_paths:
      - exact: /health
```

## Authorization

Authorization feature can be used to enable access control on workloads in the mesh. The policy supports bothÂ `ALLOW`Â andÂ `DENY`Â policies. In case when youâ€™re using both allow and deny policies at the same time, the deny policies get evaluated first. Each Envoy proxy uses an authorization engine that decides at runtime if requests should be allowed or denied.

When requests reach the proxy, the authorization engine evaluates the request and returns the authorization result - eitherÂ `ALLOW`Â orÂ `DENY`. The policies are evaluated in the following order:

1. If anyÂ `DENY`Â policy matches the request â†’ deny the request
2. If there noÂ `ALLOW`Â policies for the workload â†’ allow the request
3. If any of theÂ `ALLOW`Â policies match the request â†’ allow the request
4. Deny the request

There is no need to separately enable any authorization features. Itâ€™s enough to create and apply an authorization policy for your workloads. By default, if there are no authorization policies defined, no access control is enforced and all requests are allowed.

Authorization policy is configured using theÂ `AuthorizationPolicy`Â resource. This resource includes a selector (target workloads), action (allow or deny) and the list of rules that specify when to trigger the action.

For example, with the snippet below you can apply an authorization policy to any workloads with labelsÂ `app=greeter-service`Â andÂ `version=v2`Â set. Once the request comes to the Envoy proxy of the workload, the authorization engine checks if the traffic is coming from the principal with the provided service account (helloweb) and if the operation is a GET and theÂ `x-user`Â header is set toÂ `user-1`Â - if all these are satisfied, the request is allowed, otherwise, the request gets denied.

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
 name: greeter-service
 namespace: default
spec:
 action: ALLOW
 selector:
   matchLabels:
     app: greeter-service
     version: v2
 rules:
 - from:
   - source:
       principals: ["cluster.local/ns/default/sa/helloweb"]
   to:
   - operation:
       methods: ["GET"]
   when:
   - key: request.headers[x-user]
     values: ["user-1"]
```

We are specifically applying the authorization policy to workloads labelled withÂ `app: greeter-service`Â andÂ `version: v2`. If we wanted to apply the policy to all workloads in theÂ `default`Â namespace, we could simply omit theÂ `selector`Â field like this:

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
 name: greeter-service
 namespace: default
spec:
 rules:
 - from:
   - source:
       principals: ["cluster.local/ns/default/sa/helloweb"]
   to:
   - operation:
       methods: ["GET"]
   when:
   - key: request.headers[x-user]
     values: ["user-1"]
```

You can also define an authorization policy that applies to all workloads in your service mesh, regardless of the namespace. To do that, you need to create anÂ `AuthorizationPolicy`Â in the root namespace. By default, the root namespace isÂ `istio-system`. If you need to change it, you will have to update theÂ `rootNamespace`Â field in theÂ `MeshConfig`.

### Value matching

You can use the following matching schemes for most fields in the authorization policy:

- Exact: matches an exact string
- Prefix: matches strings that start with the specified value (`[prefix]*`). For example: â€œhello.worldâ€ matches â€œhello.world.blahâ€, but not â€œblah.hello.worldâ€
- Suffix: matches strings that end with the specified value (`*[suffix]`). For example: â€œhello.worldâ€ matches â€œblah.hello.worldâ€, but not â€œhell.world.blahâ€
- Presence: matches any value, except empty (i.e. value must be provided, but we donâ€™t care what it is as long as itâ€™s not empty)

A couple of fields are exempted and only support exact matching:

- `key`Â field under theÂ `when`Â section
- `ipBlocks`Â field under theÂ `source`Â section
- `ports`Â field under theÂ `to`Â section

Hereâ€™s an example of how to allow access to any path underÂ `/api`Â as long as itâ€™s a GET operation:

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
 name: greeter-service
 namespace: default
spec:
  selector:
    matchLabels:
      app: greeter-service
  action: ALLOW
  rules:
   - to:
    - operation:
        methods: ["GET"]
        paths: ["/api/*"]
```

### Exclusions

In addition to inclusion matching, Istio also support matching exclusions. This means you can match negative conditions likeÂ `notValues`,Â `notPorts`Â orÂ `notIpBlocks`. The following snippet allows requests that are not under theÂ `/private`Â path:

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
 name: greeter-service
 namespace: default
spec:
  selector:
    matchLabels:
      app: greeter-service
  action: ALLOW
  rules:
   - to:
    - operation:
        notPaths: ["/private"]
```

### Deny all and allow all

To create an allow all authorization policy that allows full access to all workloads in the specified namespace, you can create a policy with an empty rules section like this:

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-all
  namespace: default
spec:
  action: ALLOW
  rules:
  - {}
```

Similarly, you can deny access to all workloads by using an empty spec field:

```yaml
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: default
spec:
  {}
```

## Examples

To demonstrate the security features, we will deploy the Hello Web, Greeter service, and corresponding virtual service.

Start with the greeter deployment and service:

```sh
cat <<EOF | kubectl create -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: greeter-service-v1
  labels:
    app: greeter-service
    version: v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: greeter-service
      version: v1
  template:
    metadata:
      labels:
        app: greeter-service
        version: v1
    spec:
      containers:
        - image: learnistio/greeter-service:1.0.0
          imagePullPolicy: Always
          name: svc
          ports:
            - containerPort: 3000
---
kind: Service
apiVersion: v1
metadata:
  name: greeter-service
  labels:
    app: greeter-service
spec:
  selector:
    app: greeter-service
  ports:
    - port: 3000
      name: http
EOF
```

Then create the Hello web deployment and service:

```sh
cat <<EOF | kubectl create -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: helloweb
  labels:
    app: helloweb
    version: v1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: helloweb
      version: v1
  template:
    metadata:
      labels:
        app: helloweb
        version: v1
    spec:
      containers:
        - image: learnistio/hello-web:1.0.0
          imagePullPolicy: Always
          name: web
          ports:
            - containerPort: 3000
          env:
            - name: GREETER_SERVICE_URL
              value: 'http://greeter-service.default.svc.cluster.local:3000'
---
kind: Service
apiVersion: v1
metadata:
  name: helloweb
  labels:
    app: helloweb
spec:
  selector:
    app: helloweb
  ports:
    - port: 3000
      name: http
EOF
```

Finally, create the Virtual service for the Hello web, so that we can expose it through the gateway. Donâ€™t forget to deploy the gateway as well - check blog 3 for the snippet.

```sh
cat <<EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: helloweb
spec:
  hosts:
    - '*'
  gateways:
    - gateway
  http:
    - route:
      - destination:
          host: helloweb.default.svc.cluster.local
          port:
            number: 3000
EOF
```

If you openÂ `http://$GATEWAY`Â you should see the familiar Hello web with the response from the greeter service.

Letâ€™s use an authorization policy that denies access to all workloads:

```sh
cat <<EOF | kubectl apply -f - 
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: default
spec: {}
EOF
```

With this config, we are denying access to all workloads in theÂ `default`Â namespace.

Try refreshing theÂ `http://$GATEWAY`Â or runningÂ `curl http://$GATEWAY`. This time, it wonâ€™t work and you will see the following error:

```sh
RBAC: access denied
```

To allow Hello Web service to call to the Greeter service we can update the authorization policy that explicitly allows Hello Web making requests to the Greeter service.

Letâ€™s delete the previous policy first by running:

```sh
kubectl delete authorizationpolicy deny-all
```

Now we can create a new policy:

```sh
cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
 name: greeter-service
 namespace: default
spec:
 selector:
  matchLabels:
    app: greeter-service
 rules:
  - to: 
    - operation:
        methods: ["GET"]
EOF
```

If you try to reaccess the site, you should be able to see the responses again. Note that there might be some delays due to caching.

Letâ€™s tighten up the service role a bit more and update the authorization policy, so we can only call theÂ */hello*Â endpoint on it:

```sh
cat <<EOF | kubectl apply -f -
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
 name: greeter-service
 namespace: default
spec:
 selector:
  matchLabels:
    app: greeter-service
 rules:
  - to: 
    - operation:
        methods: ["GET"]
        paths: ["*/hello"]
EOF
```

To test this, we will get a shell inside the Hello web container and useÂ *curl*Â to make requests to the greeter service. First, letâ€™s figure out the Hello web pod name by runningÂ `kubectl get pod`Â and then run the exec command:

```sh
kubectl exec -it [podname] /bin/sh
```

With the shell inside the container, letâ€™s installÂ *curl*Â first:

```sh
apk add curl
```

We can test out the service role now. If you runÂ *curl*Â against theÂ */hello*Â endpoint, everything works as expected:

```sh
curl greeter-service.default.svc.cluster.local:3000/hello
{"message":"hello ğŸ‘‹ ","version":"1.0.0"}
```

However, if you make a request against theÂ */version*Â endpoint, you will see the familiar error message:

```sh
curl greeter-service.default.svc.cluster.local:3000/version
RBAC: access denied
```

To clean everything, simply delete the authorization policy.

## Conclusion

In this blog, you learned about how Istio service mesh deals with the security and different features you can use to define authorization policies through a couple of examples.

### See Also

- [How to use Istio to test service resiliency?](https://tetratelabs.io/blog/testing-services-with-istio/)
- [What are the patterns of resilience in Istio?](https://tetratelabs.io/blog/istio-resiliency-patterns/)
- [Hands-on walkthrough of traffic management in Istio Part 2](https://tetratelabs.io/blog/istio-traffic-management-walkthrough-p2/)
- [Hands-on walkthrough of traffic management in Istio Part 1](https://tetratelabs.io/blog/istio-traffic-management-walkthrough-p1/)
- [What's new in Istio 1.9?](https://tetratelabs.io/blog/whats-new-istio-1-9/)
